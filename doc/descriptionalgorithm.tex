\section{Описание алгоритмов}
\subsection{Bilateral}
Основная идея билатерального фильтра заключается в том, что на текущий пиксель, влияние соседних пикселей снижается как с
увеличением расстояния, так и с увеличением разницы в цветовом плане. 
\begin{equation}
x(u) = \frac{\sum_{p\in N(u)}W_c(\parallel p - u\parallel)W_s(\mid y(u) - y(p)\mid)y(p)}
{\sum_{p\in N(u)}W_c(\parallel p - u\parallel)W_s(\mid y(u) - y(p)\mid)}
\end{equation}
где
\begin{itemize}
\item x(u) - новое значение пикселя
\item u - пиксель, для которого высчитывается новое значение
\item y(u) и y(p) - значения пикселей в исходном изображении
\item N(u) - окрестность пикселя u
\item $W_c$ - весовая функция расстояния с параметров $\sigma_c$ = $exp(\frac{-x^2}{(2\sigma_c^2)})$
\item $W_s$ - весовая функция цвета с параметров $\sigma_s$ = $exp(\frac{-x^2}{(2\sigma_s^2)})$
\end{itemize}

Весовая функция подбирается в зависимости от природы шума. В данном случае выбрана функция Гаусса.

Сохранение краёв на изображении достигается за счёт весовой функции цвета. Если мы считаем новый цвет оказавшись на "темной стороне", т.е. где пиксели принимают низкие значения интенсивности , то как раз "темные" пиксели будут вносить больший вклад, в то время как более "светлые" пиксели, практически не будут влиять на результат. Диапазон интенсивности, который будет влиять на итоговое значение задаётся параметром $\sigma_s$,  при чем зависимость эта прямо пропорциональная.
Параметр $\sigma_c$ определяет радиус окрестности, которая будет влиять на итоговое значение. На практике окрестность пикселя, т.е. её радиус = 2$\sigma_c$.

Рассчитаем сложность алгоритма. Для каждого пикселя, необходимо проверить все пиксели в определенном радиусе. В таком случае сложность алгоритма = O(nr), где n - количество пикселей в изображении, r - радиус. 

Попытаемся подобрать оптимальные параметры, для каждого типа изображений. В дальнейшем будем считать, что среднеквадратичное отклонение шума равно 0.05.
В приложении \ref{app:BillRes} будут приведены полученные изображения. 