\section{Описание алгоритмов}
\subsection{Bilateral}
Основная идея билатерального фильтра заключается в том, что на текущий пиксель, влияние соседних пикселей снижается как с
увеличением расстояния, так и с увеличением разницы в цветовом плане. 
\begin{equation}
x(u) = \frac{\sum_{p\in N(u)}W_c(\parallel p - u\parallel)W_s(\mid y(u) - y(p)\mid)y(p)}
{\sum_{p\in N(u)}W_c(\parallel p - u\parallel)W_s(\mid y(u) - y(p)\mid)}
\end{equation}
где
\begin{itemize}
\item x(u) - новое значение пикселя
\item u - пиксель, для которого высчитывается новое значение
\item y(u) и y(p) - значения пикселей в исходном изображении
\item N(u) - окрестность пикселя u
\item $W_c$ - весовая функция расстояния с параметров $\sigma_c$ = $exp(\frac{-x^2}{(2\sigma_c^2)})$
\item $W_s$ - весовая функция цвета с параметров $\sigma_s$ = $exp(\frac{-x^2}{(2\sigma_s^2)})$
\end{itemize}

Весовая функция подбирается в зависимости от природы шума. В данном случае выбрана функция Гаусса.

Сохранение краёв на изображении достигается за счёт весовой функции цвета. Если мы считаем новый цвет оказавшись на "темной стороне", т.е. где пиксели принимают низкие значения интенсивности , то как раз "темные" пиксели будут вносить больший вклад, в то время как более "светлые" пиксели, практически не будут влиять на результат. Диапазон интенсивности, который будет влиять на итоговое значение задаётся параметром $\sigma_s$,  при чем зависимость эта прямо пропорциональная.
Параметр $\sigma_c$ определяет радиус окрестности, которая будет влиять на итоговое значение. На практике окрестность пикселя, т.е. её радиус = 2$\sigma_c$.

Рассчитаем сложность алгоритма. Для каждого пикселя, необходимо проверить все пиксели в определенном радиусе. В таком случае сложность алгоритма = $O(nr^2)$, где n - количество пикселей в изображении, r - радиус. 

Одним из главных преимуществ данного фильгятра, является его простота, а так же сохранение границ. К сожалению, он так же обладает и рядом недостатков, среди которых:

\begin{itemize}
	\item Долгое время работы
	\item Артефакты на краях изображения
\end{itemize}

Попытаемся подобрать оптимальные параметры, для каждого типа изображений. В дальнейшем будем считать, что среднеквадратичное отклонение шума равно 0.05.
В приложении \ref{app:BillRes} будут приведены полученные изображения.


\subsection{Guided filter}
Идея, заключается в том, что бы определить линейную зависимость каждого пикселя итогового изображения $x$ от опорного изображения $I$ в каждом окне $\omega_k$ с центральным пикселем $k$, по следующей формуле:
\begin{equation}\label{eq:Guided}
	x_i = \overline{a_i}I_i + \overline{b_i}=\frac{1}{|\omega|}\sum_{k|i\in\omega_k}(a_kI_i+b_k)
\end{equation} 
где: $|\omega|$ - количество пикселей в заданном окне $\omega_k$;

$\overline{b_i}$ и $\overline{a_i}$- средние значения линейных коэффициентов $a_i$ и $b_i$ во всех окнах, которые включают в себя пиксель $i$
$a_i$ и $b_i$ - линейные коэффициенты для каждого окна $\omega_k$, которые вычисляются следующим образом:
\begin{equation}
a_k=\frac{\frac{1}{|\omega|}\sum_{i\in\omega_k}I_ip_i+\mu_k\overline{p_k}}{\sigma_k^2+\varepsilon}
\end{equation}
\begin{equation}
b_k=\frac{1}{|\omega|}\sum_{i\in\omega_k}p_i-a_k\mu_k=\overline{p_k} - a_k\mu_k
\end{equation}
где: $\mu_k$ и $\sigma^2$ - среднее значение и дисперсия опорного изображения $I$ в окне $\omega_k$;
$\overline{p_k}$ - среднее значение входного изображения $p$в окне $\omega_k$;
$\varepsilon$ - параметр регуляризации параметра $a_k$ что бы ограничить его рост.

Уравнение \ref{eq:Guided}  можно переписать в след. виде \cite{He}:
\begin{equation}
q = \sum_j W_ij(I)pj
\end{equation}
где
\begin{equation}
W_ij(I)=\frac{1}{|\omega|^2} \sum_{k:(i,j)\in \omega_k}(1 + \frac{(I_i-\mu_k)(I_j-\mu_k)}{\sigma_k^2 + \varepsilon})
\end{equation}
Это позволит сделать вычисления не зависимыми от величины окна $\omega_k$. И весь алгоритм может быть представлен следующим образом.

\begin{align*}
	\dot mean_I = boxfilter(I,r)
	\dot mean_p = boxfilter(p,r)
	\dot corr_I = boxfilter(I.*I,r)
	\dot corr_I = boxfilter(I.*p,r)
	\dot var_I  = corr_I - mean_I.*mean_I
	\dot cov_Ip = corr_Ip - mean_I.*mean_p
	\dot a = \frac{cov_Ip}{var_I + \varepsilon}
	\dot b = mean_p - a.*mean_I
	\dot mean_a = boxfilter(a,r)
	\dot mean_b = boxfilter(b,r)
	\dot q = mean_a.*I+mean_b
\end{align*}
Свойства сохранения краев можно объяснить следующим способом, возьмем вспомогательное изображение равное исходному т.е. $I=p$, в таком случае могу быть рассмотрены два крайних случая.
В случае, когда  окно будет гладким, т.е. значения пикселей будут мало отличаться друг от друга, в таком случае параметр $a_k=0$, а $b_k=\overline{p_k}$. 
В противоположном случае, $a_k=1$, а $b_k=0$.
Влияние параметра $\varepsilon$, можно описать следующим образом. Если среднее отклонение $\sigma^2$ меньше, чем $\varepsilon$, то область размывается, в ином случае она остается неизменной.

Главное особенностью данного фильтра является то, что его сложность зависит только от количества пикселей в изображении, т.е. $O(n)$ где $n$ - количество пикселей

\subsection{Non-Local mean}
Обычно, новое значение пикселя берется как некое усредненное значение его соседей. К таким фильтрам относятся: билатеральный фильтр, box фильтер и фильтер гаусса. Развитием этой идеи стал фильтр NL-mean. Суть его заключается в том, что бы искать похожие куски изображения на всей области изображения и брать некое среднее значение. 
\begin{equation}\label{eq:nl}
	x_i=\sum_j w(i,j)v(j)
\end{equation}
где
\begin{itemize}
\item $x_i$ - итоговое значение пикселя.
\item $w(i,j)$ - весовая функция, которая сравнивает две области изображения, с центром в пикселе i и j
\item $v(j)$ - интенсивность пикселя j
\end{itemize}
Уравнение \ref{eq:nl} указывает зависимость между значением итогового пикселя и всех пикселей исходного, зашумленного изображения.
\begin{equation}
	w(i,j) = \frac{exp(-\frac{\parallel{N(i)-N(j)}\parallel_{2,a}^2}{h})}{\sum_{j \in I}exp(-\frac{\parallel{N(i)-N(j)}\parallel_{2,a}^2}{h})}\
\end{equation}
где
\begin{itemize}
	\item h - параметр указывает степень фильтрации, чем он меньше, тем менее похожие патерны изображения будут влиять на итоговый пиксель
	\item N(i) и N(j) - соседи пикселей i и j
	\item a - стандартное распределение гауссовского фильтра
\end{itemize}
Не трудно заметить, что сложность данного алгоритма $O(n^2(r*2+1))$, это приводит к значительным временным затратам даже для изображений малых размеров.
Для уменьшения сложности вычисления, можно сделать следующие упрощения: можно заранее рассчитать все веса, так как область одного и того же пикселя может использоваться несколько раз, можно уменьшить окно поиска похожих патчей, т.е. теперь похожие патчи буду искаться не во всем изображении, а в некотором окне.  Так же можно сравнивать расстояния не для каждого пикселя, а через один, два и т.д. Тогда сложность будет= $O(n*N*(r*2+1))$, где N размер большого окна.

\subsection{BM3D}
Фильтр BM3D можно считать более лучшей версией алгоритма Non-Local mean. В нём так же одним из ключевых моментов является
усреднение значений посредством поиска похожих блоков. В алгоритме можно выделить два основных шага. Каждый шаг в свою очередь разбивается на 3 этапа. Первый этап называется группировка ($grouping$), в котором для каждого патча (часть изображения фиксированного размера), отбираются другие похожие патчи. Вторым этапом является совместная ($collaborative$) фильтрация. Третьим этапом является агрегация, где для каждого пикселя вычисляется новое значение, с учетом того, что данный пиксель мог находится в различных патчах.
Далее патчем будет обозначаться часть исходного изображения с фиксированным размером.
\subsubsection{Первый шаг}
\paragraph{Группировка}\

Всё изображение разбивается на патчи (блоки), которые имеют размером - $N_{ht}^{Psize}$.  Далее для каждого патча, обозначим его $P$, производятся следующие действия. В окне размера - $N_{ht}^Wsize$, в котором центром является $P$, с шагом - $N_{ht}^{Sstep}$ ищутся похожие блоки  \ref{eq:l2bm3d}.
\begin{equation}\label{eq:l2bm3d}
	G_{ht}(P) = \left\{Q | d_{ht}(Q,P) \leq h_{ht}\right\}
\end{equation}
где
\begin{itemize}
	\item $G_{ht}(P)$ - множество блоков схожих с P
	\item Q - один из блоков в окне
	\item $d_{ht}(Q,P) = \frac{\parallel\gamma_{\lambda_{ht}^{2D}}(P)-\gamma_{\lambda_{ht}^{2D}}(Q)\parallel_2^2}{(N_{ht}^{Psize})^2}$
	\item $\gamma_{\lambda}(x) = \begin{cases}0 &|x| \leq \lambda\\ x & |x| > \lambda\end{cases}$ - жесткая пороговая фильтрация 
	\item $\lambda_{ht}^{2d}$ - для низких значений шума $\sigma < 40$ обычно равняется нулю, подробнее \cite{dabov}
	\item $\sigma^2$ -  дисперсия шума
	\item $h_{ht}$ - порог, для того, что бы считать два блока похожими.
\end{itemize}
Максимальное количество подходящих блоков так же ограничивают, за это отвечает параметр - $N_{ht}^{Pmax}$. Найденные блоки объединяются в 3D-блок, далее обозначаемый $G_{ht}^{3D}(P)$,в котором блоки располагаются по мере уменьшения схожести.

\paragraph{Совместная фильтрация}\

К $G_{ht}^{3D}(P)$ применяется 3D преобразование - $r_{ht}^{3D}$, трансформирующие его в частотную область, после применяется жесткая пороговая фильтрация $\gamma_{\lambda_{ht}^{3D}}$. После данных операций происходит обратное 3D преобразование - $r_{ht}^{3D^{-1}}$ . Данные действия описываются следующей формулой.
\begin{equation}
G_{ht}^{3D'}(P) = r_{ht}^{3D^{-1}}(\gamma_{\lambda_{ht}^{3D}}(r_{ht}^{3D}(G_{ht}^{3D}(P))))
\end{equation}

\paragraph{Агрегация}\

Теперь для каждого пикселя в изображении, необходимо рассчитать новое значение. При этом нужно учесть, что пиксель мог находится в нескольких $G_{ht}^{3D'}$. Итоговая формула следующая.
\begin{equation}
	y^{basic}(x) = \frac{\sum\limits_Pw_p^{hard}\sum\limits_{Q \in G_{ht}^{3D'}(P)}\chi_Q(x)u_{P,Q}(x)}{\sum\limits_Pw_p^{ht}\sum\limits_{Q \in G_{ht}^{3D'}(P)}\chi_Q(x)}
\end{equation}
где
\begin{itemize}
	\item $y^{basic}(x)$ - значение пикселя после первого шага 
	\item $w_p^{ht}  = \begin{cases}(N_p^{hard})^{-1} & N_p^{hard} \geq 1\\ 1 & N_p^{hard} < 1 \lambda\end{cases}$
	\item $N_p^{hard}$ - количество ненулевых пикселей после $\gamma_{\lambda_{ht}^{3D}}(r_{ht}^{3D}(G_{3D}(P))$
	\item $\chi_Q(x)$ - равняется 1, если $x\in Q$
\end{itemize}

\subsubsection{Второй шаг}
На основе $y^{basic}$ можно получить более лучшее шумоподавления, применяя фильтр Винера. Патч, для которого произведены дальнейшие действия обозначим $P^{basic}$
\paragraph{Группировка}\

Будем считать, что количество шума после первого шага сведенно к минимуму. Определим формулу, для поиска подходящих блоков на втором шаге.
\begin{equation}
	G_{wie}(P^{basic}) = \left\{Q | d_{wie}(Q,P^{basic}) \leq h_{wie}\right\}
\end{equation}
где
\begin{itemize}
	\item $G_{wie}(P^{basic})$ - множество блоков схожих с $P^{basic}$
	\item Q - один из блоков в окне
	\item $d_{wie}(Q,P^{basic}) = \frac{\parallel P^{basic} - Q\parallel_2^2}{(N_{ht}^{Psize})^2}$
	\item $h_{wie}$ - порог, для того, что бы считать два блока похожими.
\end{itemize}

\paragraph{Совместная фильтрация}
Объединим блоки найденные на этапе группировка второго шага в $G_{wie}^{3D}(P^{basic})$. Затем применим 3D преобразование - - $r_{wie}^{3D}$, как в первом шаге. Применим фильтр Винера: поэлементно умножим $G_{wie}^{3D}(P^{basic})$ на коэффициент сжатия Винера - $w_P$. После, применим обратное 3D преобразование - $r_{ht}^{3D^{-1}}$. Опишем эти действия следующей формулой.
\begin{equation}
G_{wie}^{3D'}(P^{basic}) = r_{wie}^{3D^{-1}}(w_P \cdot r_{wie}^{3D}(G_{wie}^{3D}(P)))
\end{equation}
где
\begin{itemize}
\item  $w_P = \frac{|r_{wie}^{3D}(G_{wie}^{3D}(P^{basic})|^2}{|r_{wie}^{3D}(G_{wie}^{3D}(P^{basic})|^2 + \sigma} $
\end{itemize}
\paragraph{Агрегация}\

Агрегация на втором шаге проводится по следующей формуле.
\begin{equation}
y(x) = \frac{\sum\limits_Pw_p^{wie}\sum\limits_{Q \in G_{wie}^{3D'}(P)}\chi_Q(x)u_{P,Q}(x)}{\sum\limits_Pw_p^{wie}\sum\limits_{Q \in G_{wie}^{3D'}(P)}\chi_Q(x)}
\end{equation}
где
\begin{itemize}
	\item $y(x)$ - итоговое значение пикселя
	\item $w_P^{wie}  = \parallel w_P \parallel_2^{-2}$ 
\end{itemize}

\subsubsection{Оптимальные параметры}
Согласно \cite{bm3d}, оптимальными параметрами будут следующие:

\begin{tabular}{|c|c|c|}
	\hline
	Обозначение параметра & $\sigma \leq 40$ & $\sigma > 40$\\
	\hline
	$N_{ht}^{Pmax}$ & 16 & 16 \\
	\hline
	$N_{wie}^{Pmax}$ & 32 & 32 \\
	\hline
	$N_{ht}^{Psize}$ & 8 & 8 \\
	\hline
	$N_{wie}^{Psize}$ & 8 & 8 \\
	\hline
	$\lambda_{ht}$ & 2.7 & 2.7 \\
	\hline
	$h_{ht}$ & 2500 & 5000 \\
	\hline
	$h_{wie}$ & 400 & 3500 \\ 
	\hline
	
\end{tabular}

\subsection{Total Variation}
Алгоритм основан на следующем предположение. TV у зашумленного
изображения больше чем у оригинала. Соответственно, необходимо найти
такое изображение, которое минимизирует TV. Если ограничиться лишь
данным условием, то найденное изображение будет полностью черным.
Поэтому вводится дополнительное ограничение, найденное изображение и
зашумленное должны быть максимально похожи
\begin{equation}\label{eq:TV}
J(x)=\parallel y-x \parallel^2_2 + \lambda\parallel TV(x)\parallel_1
\end{equation}
где
\begin{itemize}
	\item J(x) - функция, которую нужно минимизировать
	\item y - зашумленное изображение
	\item x - изображение после шумоподавления
	\item $\lambda$ - регуляризационный параметр 
\end{itemize}
Уравнение \ref{eq:TV} является оптимизационной задачей.
\subsection{Random Markov Field}